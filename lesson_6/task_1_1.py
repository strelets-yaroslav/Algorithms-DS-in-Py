"""Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
в рамках первых трех уроков. Проанализировать результат и определить программы
с наиболее эффективным использованием памяти."""


from math import log, sqrt
from memory_profiler import profile


# import sys
# print(sys.version, sys.platform)
# 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)] win32


@profile
def sieve(k):
    """Решето Эратосфена."""
    n = int(1.5 * k * log(k)) + 1  # верхняя оценка для простого числа

    if n < 2:
        return n

    num_list = [i for i in range(n)]
    s_count, s_num, i = 0, 0, 2
    while s_count < k:
        if num_list[i] != 0:
            s_num = num_list[i]
            s_count += 1
            for j in range(i, n, i):
                num_list[j] = 0
        i += 1

    return s_num

# Line #    Mem usage    Increment  Occurrences   Line Contents
# =============================================================
#     10     20.5 MiB     20.5 MiB           1   @profile
#     11                                         def sieve(k):
#     12                                             """Решето Эратосфена."""
#     13     20.5 MiB      0.0 MiB           1       n = int(1.5 * k * log(k)) + 1  # верхняя оценка для простого числа
#     14
#     15     20.5 MiB      0.0 MiB           1       if n < 2:
#     16                                                 return n
#     17
#     18     24.1 MiB      3.6 MiB       63882       num_list = [i for i in range(n)]
#     19     24.1 MiB      0.0 MiB           1       s_count, s_num, i = 0, 0, 2
#     20     24.2 MiB -12317.0 MiB       48611       while s_count < k:
#     21     24.2 MiB -12316.0 MiB       48610           if num_list[i] != 0:
#     22     24.2 MiB  -1160.5 MiB        5000               s_num = num_list[i]
#     23     24.2 MiB  -1160.5 MiB        5000               s_count += 1
#     24     24.2 MiB  -2504.8 MiB      171116               for j in range(i, n, i):
#     25     24.2 MiB  -1344.2 MiB      166116                   num_list[j] = 0
#     26     24.2 MiB -12317.0 MiB       48610           i += 1
#     27
#     28     23.2 MiB     -1.0 MiB           1       return s_num

# Вывод: основное использование памяти - хранение всех чисел для дальнейшего использования


@profile
def simple_num(k):
    """Поиск простых чисел: используется проход только по нечётным, а также
       исключаются кратные 5 (большие 10). Также не используем память для исходных чисел."""
    s_num_list = [2]
    s_count, num = 1, 3
    while s_count < k:
        if (num > 10) and (num % 10 == 5):
            num += 2
            continue
        for s_num in s_num_list:
            if s_num * s_num - 1 > num:  # проверять нужно только числа, меньшие корня из текущего.
                s_num_list.append(num)
                s_count += 1
                break
            if num % s_num == 0:  # число кратно текущему простому.
                break
        else:  # в цикле не сработало ни одно условие прерывания - значит, простое.
            s_num_list.append(num)
            s_count += 1
        num += 2

    res = s_num_list[-1]

    return res

# Line #    Mem usage    Increment  Occurrences   Line Contents
# =============================================================
#     58     21.6 MiB     21.6 MiB           1   @profile
#     59                                         def sieve_2(k):
#     60                                             """Оптимизированное решето - используется массив флагов для чисел."""
#     61     21.6 MiB      0.0 MiB           1       n = int(1.5 * k * log(k)) + 1
#     62
#     63     21.6 MiB      0.0 MiB           1       if n < 2:
#     64                                                 return n
#     65
#     66     22.1 MiB      0.5 MiB           1       flags = [1] * n  # флаги для чисел, 0-й относится к простому числу 2
#     67     22.1 MiB      0.0 MiB           1       sqrt_n = int(sqrt(n)) + 1  # проверять можно только числа, меньшие корня из верхней границы
#     68     22.1 MiB     -8.5 MiB         252       for i in range(2, sqrt_n):
#     69     22.1 MiB     -8.5 MiB         251           if flags[i - 2]:  # если флаг взведён, то на данной итерации это простое число.
#     70     22.1 MiB  -1611.3 MiB      126688               for j in range(i + i, n + 1, i):  # обнуляем флаги для всех чисел, кратных ему.
#     71     22.1 MiB  -1609.5 MiB      126634                   flags[j - 2] = 0
#     72
#     73                                             # к-е простое число находим как индекс к-го взведённого флага в получившемся массиве.
#     74     22.1 MiB     -0.0 MiB           1       i = 0
#     75     22.1 MiB      0.0 MiB       48611       while k:
#     76     22.1 MiB      0.0 MiB       48610           k -= flags[i]
#     77     22.1 MiB      0.0 MiB       48610           i += 1
#     78
#     79     22.1 MiB      0.0 MiB           1       return i + 1

# Вывод: хранение только флагов по индексам-числам уменьшает использование памяти в несколько раз.


@profile
def sieve_2(k):
    """Оптимизированное решето - используется массив флагов для чисел."""
    n = int(1.5 * k * log(k)) + 1

    if n < 2:
        return n

    flags = [1] * n  # флаги для чисел, 0-й относится к простому числу 2
    sqrt_n = int(sqrt(n)) + 1  # проверять можно только числа, меньшие корня из верхней границы
    for i in range(2, sqrt_n):
        if flags[i - 2]:  # если флаг взведён, то на данной итерации это простое число.
            for j in range(i + i, n + 1, i):  # обнуляем флаги для всех чисел, кратных ему.
                flags[j - 2] = 0

    # к-е простое число находим как индекс к-го взведённого флага в получившемся массиве.
    i = 0
    while k:
        k -= flags[i]
        i += 1

    return i + 1

# Line #    Mem usage    Increment  Occurrences   Line Contents
# =============================================================
#     31     21.3 MiB     21.3 MiB           1   @profile
#     32                                         def simple_num(k):
#     33                                             """Поиск простых чисел: используется проход только по нечётным, а также
#     34                                                исключаются кратные 5 (большие 10). Также не используем память для исходных чисел."""
#     35     21.3 MiB      0.0 MiB           1       s_num_list = [2]
#     36     21.3 MiB      0.0 MiB           1       s_count, num = 1, 3
#     37     21.3 MiB      0.0 MiB       24306       while s_count < k:
#     38     21.3 MiB      0.0 MiB       24305           if (num > 10) and (num % 10 == 5):
#     39     21.3 MiB      0.0 MiB        4860               num += 2
#     40     21.3 MiB      0.0 MiB        4860               continue
#     41     21.3 MiB      0.0 MiB      270593           for s_num in s_num_list:
#     42     21.3 MiB      0.0 MiB      270592               if s_num * s_num - 1 > num:  # проверять нужно только числа, меньшие корня из текущего.
#     43     21.3 MiB      0.1 MiB        4998                   s_num_list.append(num)
#     44     21.3 MiB      0.0 MiB        4998                   s_count += 1
#     45     21.3 MiB      0.0 MiB        4998                   break
#     46     21.3 MiB      0.0 MiB      265594               if num % s_num == 0:  # число кратно текущему простому.
#     47     21.3 MiB      0.0 MiB       14446                   break
#     48                                                 else:  # в цикле не сработало ни одно условие прерывания - значит, простое.
#     49     21.3 MiB      0.0 MiB           1               s_num_list.append(num)
#     50     21.3 MiB      0.0 MiB           1               s_count += 1
#     51     21.3 MiB      0.0 MiB       19445           num += 2
#     52
#     53     21.3 MiB      0.0 MiB           1       res = s_num_list[-1]
#     54
#     55     21.3 MiB      0.0 MiB           1       return res

# Вывод: использование памяти минимально - только для хранения самих простых чисел

# Общий вывод: оптимизированное решето даёт лучший эффект в оптимизации как использования памяти,
# так и производительности.
# Хотя обычный поиск простых чисел имеет преимущество в использовании памяти, но по производительности он уступает.
# Наиболее эффективный алгоритм - sieve_2, оптимизированное решето.

if __name__ == '__main__':
    n = 5000
    sieve(n)
    print('*' * 50)
    sieve_2(n)
    print('*' * 50)
    simple_num(n)
